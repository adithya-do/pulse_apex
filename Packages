CREATE OR REPLACE PACKAGE encrypt_pkg AUTHID DEFINER AS
  FUNCTION hash_password(p_plain IN VARCHAR2, p_salt OUT RAW) RETURN RAW;
  FUNCTION verify_password(p_plain IN VARCHAR2, p_salt IN RAW, p_hash IN RAW) RETURN NUMBER; -- 1 match / 0 no
  FUNCTION enc_secret(p_plain IN VARCHAR2) RETURN RAW;   -- returns IV||CIPHERTEXT
  FUNCTION dec_secret(p_raw   IN RAW) RETURN VARCHAR2;   -- expects IV||CIPHERTEXT
END encrypt_pkg;
/
SHOW ERRORS;

CREATE OR REPLACE PACKAGE BODY encrypt_pkg AS
  -------------------------------------------------------------------------
  -- Replace this with your own 32-byte key and keep the BODY locked down.
  -------------------------------------------------------------------------
  g_key  RAW(32) := HEXTORAW('7B1D0F8C6A55A4E91F3B2C4D5E6F70811223344556677889900AABBCCDDEEFF0');
  g_iter CONSTANT PLS_INTEGER := 20000;

  FUNCTION pbkdf_sha512(p_data RAW, p_salt RAW, p_iter PLS_INTEGER) RETURN RAW IS
    l_hash RAW(64);
  BEGIN
    l_hash := DBMS_CRYPTO.HASH(p_data || p_salt, DBMS_CRYPTO.HASH_SH512);
    FOR i IN 1 .. p_iter LOOP
      l_hash := DBMS_CRYPTO.HASH(l_hash || p_salt, DBMS_CRYPTO.HASH_SH512);
    END LOOP;
    RETURN l_hash;
  END;

  FUNCTION hash_password(p_plain IN VARCHAR2, p_salt OUT RAW) RETURN RAW IS
    l_raw RAW(2000) := UTL_RAW.CAST_TO_RAW(p_plain);
  BEGIN
    p_salt := DBMS_CRYPTO.RANDOMBYTES(16);
    RETURN pbkdf_sha512(l_raw, p_salt, g_iter);
  END;

  FUNCTION verify_password(p_plain IN VARCHAR2, p_salt IN RAW, p_hash IN RAW) RETURN NUMBER IS
    l_raw RAW(2000) := UTL_RAW.CAST_TO_RAW(p_plain);
  BEGIN
    RETURN CASE WHEN pbkdf_sha512(l_raw, p_salt, g_iter) = p_hash THEN 1 ELSE 0 END;
  END;

  FUNCTION enc_secret(p_plain IN VARCHAR2) RETURN RAW IS
    l_iv RAW(16) := DBMS_CRYPTO.RANDOMBYTES(16);
    l_ct RAW(32767);
  BEGIN
    l_ct := DBMS_CRYPTO.ENCRYPT(
              src => UTL_RAW.CAST_TO_RAW(p_plain),
              typ => DBMS_CRYPTO.ENCRYPT_AES256 + DBMS_CRYPTO.CHAIN_CBC + DBMS_CRYPTO.PAD_PKCS5,
              key => g_key,
              iv  => l_iv);
    RETURN l_iv || l_ct;
  END;

  FUNCTION dec_secret(p_raw IN RAW) RETURN VARCHAR2 IS
    l_iv RAW(16);
    l_ct RAW(32767);
    l_pt RAW(32767);
  BEGIN
    l_iv := UTL_RAW.SUBSTR(p_raw, 1, 16);
    l_ct := UTL_RAW.SUBSTR(p_raw, 17);
    l_pt := DBMS_CRYPTO.DECRYPT(
              src => l_ct,
              typ => DBMS_CRYPTO.ENCRYPT_AES256 + DBMS_CRYPTO.CHAIN_CBC + DBMS_CRYPTO.PAD_PKCS5,
              key => g_key,
              iv  => l_iv);
    RETURN UTL_RAW.CAST_TO_VARCHAR2(l_pt);
  END;
END encrypt_pkg;
/
SHOW ERRORS;


CREATE OR REPLACE PACKAGE auth_pkg AUTHID DEFINER AS
  FUNCTION login(p_login IN VARCHAR2, p_password IN VARCHAR2) RETURN NUMBER;  -- user_id or NULL
  PROCEDURE set_password(p_user_id IN NUMBER, p_new IN VARCHAR2);
  PROCEDURE create_user(p_login IN VARCHAR2, p_full IN VARCHAR2, p_email IN VARCHAR2,
                        p_temp_password OUT VARCHAR2);
  PROCEDURE forgot_password(p_login IN VARCHAR2);
END auth_pkg;
/
SHOW ERRORS;

CREATE OR REPLACE PACKAGE BODY auth_pkg AS
  -- Generate a hex password of length p_len using DBMS_CRYPTO only.
  FUNCTION gen_temp_password(p_len PLS_INTEGER DEFAULT 16) RETURN VARCHAR2 IS
    -- 32 hex chars come from 16 random bytes; take as many as needed.
    l_hex VARCHAR2(4000) := LOWER(RAWTOHEX(DBMS_CRYPTO.RANDOMBYTES(32)));
  BEGIN
    RETURN SUBSTR(l_hex, 1, LEAST(p_len, LENGTH(l_hex)));
  END;

  FUNCTION login(p_login IN VARCHAR2, p_password IN VARCHAR2) RETURN NUMBER IS
    l_uid    app_users.user_id%TYPE;
    l_hash   app_users.pwd_hash%TYPE;
    l_salt   app_users.pwd_salt%TYPE;
    l_active app_users.is_active%TYPE;
  BEGIN
    SELECT user_id, pwd_hash, pwd_salt, is_active
      INTO l_uid,   l_hash,   l_salt,   l_active
      FROM app_users
     WHERE login_name = LOWER(p_login);

    IF l_active <> 'Y' THEN
      RETURN NULL;
    END IF;

    IF encrypt_pkg.verify_password(p_password, l_salt, l_hash) = 1 THEN
      RETURN l_uid;
    ELSE
      RETURN NULL;
    END IF;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN NULL;
  END;

  PROCEDURE set_password(p_user_id IN NUMBER, p_new IN VARCHAR2) IS
    l_salt RAW(2000);
    l_hash RAW(2000);
  BEGIN
    l_hash := encrypt_pkg.hash_password(p_new, l_salt);
    UPDATE app_users
       SET pwd_hash        = l_hash,
           pwd_salt        = l_salt,
           must_change_pwd = 'N',
           updated_at      = SYSTIMESTAMP
     WHERE user_id         = p_user_id;
  END;

  PROCEDURE create_user(p_login IN VARCHAR2, p_full IN VARCHAR2, p_email IN VARCHAR2,
                        p_temp_password OUT VARCHAR2) IS
    l_salt RAW(2000);
    l_hash RAW(2000);
  BEGIN
    p_temp_password := gen_temp_password(16);
    l_hash := encrypt_pkg.hash_password(p_temp_password, l_salt);

    INSERT INTO app_users (login_name, full_name, email, pwd_hash, pwd_salt,
                           is_active, must_change_pwd, created_at)
    VALUES (LOWER(p_login), p_full, p_email, l_hash, l_salt, 'Y', 'Y', SYSTIMESTAMP);
  END;

  PROCEDURE forgot_password(p_login IN VARCHAR2) IS
    l_uid   app_users.user_id%TYPE;
    l_email app_users.email%TYPE;
    l_temp  VARCHAR2(64);
  BEGIN
    SELECT user_id, email
      INTO l_uid,  l_email
      FROM app_users
     WHERE login_name = LOWER(p_login);

    l_temp := gen_temp_password(16);
    set_password(l_uid, l_temp);

    -- Email the temp password (APEX mail must be configured + ACL in place)
    APEX_MAIL.SEND(
      p_to   => l_email,
      p_from => 'no-reply@yourdomain',
      p_subj => 'Your temporary password',
      p_body => 'Hello,' || CHR(10) ||
                'Your temporary password is: ' || l_temp || CHR(10) ||
                'Please log in and change it immediately.'
    );
    COMMIT;  -- enqueue the mail

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      NULL;  -- Donâ€™t reveal whether the login exists
  END;
END auth_pkg;
/
SHOW ERRORS;

